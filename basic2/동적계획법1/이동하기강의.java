package 동적계획법1;

/**
 * Created by masinogns on 2017. 9. 6..
 *
 * 방법1
 * 내가 푼 경우와 같다. 전에 것들로 찾는 것을 구한
 * D[i][j] = 1,1에서 시작해서 i,j로 가는 경우
 *
 * 방법2 i,j에서 한 칸 더 움직였을 때의 경로
 *
 * i,j에서 i+1, j
 *  D[i+1][j] = D[i][j] + A[i+1][j]
 * i,j에서 i, j+1
 *  D[i][j+1] = D[i][j] + A[i][j+1]
 * i,j에서 i+1, j+1로 가는 방법
 * D[i+1][j+1] = D[i][j] + A[i+1][j+1]
 *
 *
 * 방법 3 대각선 이동은 필요가 없
 *
 *
 * 지금까지의 점화식은 1,1 --> i,j로 이동했을 때 가져올 수 잇는 최대 사탕의 갯수
 *      1,1 --> i,j 는 D[N][M]에 값이 들어있다
 * 이제는 i,j에서 n,m으로 이동을 시작했을 때 가져올 수 잇는 최대 사탕의 갯수로 풀어보자
 *      i,j에서 n,m 은 D[1][1]에 값이 들어있다????
 *
 *
 *      i,j --> i+1, j or i, j+1 --> N,M
 *      A[i][j]+D[i+1][j]
 *      A[i][j]+D[i][j+1]
 */
public class 이동하기강의 {
}
